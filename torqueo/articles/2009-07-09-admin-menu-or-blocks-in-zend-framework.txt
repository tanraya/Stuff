title: "Меню администратора, или блоки в Zend Framework."
tags:
- plugins
- zend-framework
- zf-front-controller-plugin
- zf-layout

<body>
<p>Продолжаю серию постов о <strong>Zend Framework</strong>.

В моем проекте передо мной встала задача. Мне нужно было сделать меню администратора, которое бы появлялось на странице при определенных событиях (например, после аутентификации).

Сначала я хотел решить эту задачу, определив базовый контроллер для всех контроллеров моего проекта. Но, я подумал, что это не лучший способ решения задачи, потому как я нашел более привлекательный метод - использовать плагин для фронт-контроллера. Такое решение мне показалось лучшим потому, что мы получаем менее связанный код. Чтобы убрать меню - нам придется всего лишь отключить плагин фронт-контроллера - это все. Нас опять выручают плагины!
~

Нам понадобится написать код плагина. Далее, я расскажу, как он работает. Итак, код:
</p>
<div class="gist-wrapper"><script src="https://gist.github.com/1768668.js?file=gistfile1.php"></script></div>
Теперь прокомментирую код.

Этот плагин срабатывает перед запуском цикла диспетчеризации, это обеспечивается определением метода <em>dispatchLoopStartup(), </em>в<em> </em>который<em> </em>передается объект текущего запроса. Видно, что логика метода завернуто в условие, которое определяет, что код не должен выполняться для <em>AJAX</em> запросов - нам же не нужно кашу к примеру, из <em>JSON</em> и нашего меню? :)

Дальше мы получаем стек плагин, управляющий стеком действий. Затем клонируем объект текущего запроса и устанавливаем при помощи аксессоров объекта свои значения контроллера, действия и модуля (так как мой проект имеет модульную структуру контроллеров).

В конце метода мы кладем в стек наш клонированный и настроенный объект запроса.

Итак, что получилось? Получилось, что мы создали новый объект запроса путем клонирования, которому установили значения модуля, контроллера и действия, а затем поместили его в стек действий. Плагин <em>Zend_Controller_Plugin_ActionStack </em>последовательно производит диспетчеризацию запросов из стека, после диспетчеризации основного действия (плагин делает это в хуке postDispatch()).

<strong>Важно!</strong> Не забудьте подключить к фронт-контроллеру плагин <em>Zend_Controller_Plugin_ActionStack</em> обслуживающий стек действий. Без него наш плагин <em>Project_Controller_Plugin_Toolbar </em>работать не будет.
<div class="gist-wrapper"><script src="https://gist.github.com/1768671.js?file=gistfile1.php"></script></div>
И, конечно, не забываем подключить и наш свеженаписанный плагин:
<div class="gist-wrapper"><script src="https://gist.github.com/1768672.js?file=gistfile1.php"></script></div>
А что же происходит в нашем контроллере ToolbarController? Там все просто - в методе <em>indexAction()</em> мы указываем, в какой сегмент макета выводить отрендеренный шаблон вида:
<div class="gist-wrapper"><script src="https://gist.github.com/1768673.js?file=gistfile1.php"></script></div>
А в макете вывод сегмента выглядит так:
<div class="gist-wrapper"><script src="https://gist.github.com/1768675.js?file=gistfile1.php"></script></div>
Ну вот - наше меню готово. У меня появились мысли, сделать универсальный механизм для работы с блоками, чтобы не писать отдельных плагинов для каждого блока на сайте. Я имею в виду те блоки, которые не кочуют из проекта в проект, как меню администратора, а используются только на конкретном сайте. Я пока не придумал, как реализовать такой механизм красиво, но зачатки мыслей уже есть и их нужно еще раз обдумать и реализовать. Как сделаю - напишу об этом отдельный пост.

Всем спасибо за внимание :)</body>
